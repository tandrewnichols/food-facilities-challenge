# Food Facilities Challenge

### Considerations

1. **Npm packages** - There are probably more than strictly necessary, but I scaffolded this from my common setup, so some common dependencies may be represented here even if they aren't used.
2. **createGlobPatternsForDependencies** - I'm disabling the nx utility createGlobPatternsForDependencies within my tailwind config because on hot reload it warns "The `content` option in your Tailwind CSS configuration is missing or empty." This is an error I've seen in other repos and for which there are existing issues on the nx repo. It's not a configuration problem, but a bug somewhere in their dependency graph logic.
3. **Auth** - I'm bascially giving this no consideration since the requirements are unclear on the use case for this, but an ideal web app would have authentication - possibly through a 3rd party like Clerk or Auth0 - as well a robust role and permission model/RBAC to limit who can and cannot perform particular actions using the tool.
4. **Data normalization** - I'd normally normalize the data structure more (e.g. blocklot vs block + lot, latitdue + longitude vs location, etc.), but as the data structures already existed, I basically mapped them one to one. 
5. **Multiple search endpoints** - I originally considered doing all three search requirements in a single endpoint, and I do think that is still possible, but it makes the logic pretty messy, and the requirements seemed pretty distinct, so I made them distinct endpoints with distinct search interfaces for each.
6. **Drizzle** - Why drizzle? I've never used it, and I don't have a go to ORM, but I've heard good things about this one and figured I'd give it a try. It was _fine_ . . . some pros and some cons, just like other ORMs I've used (typeorm, prisma). I honestly kind of like just raw sql, but just like typescript, I think that is a pattern that is less accessible for younger devs and can get cluttered quickly if you don't know what you're doing. Biggest pro is it's pretty flexible - lots of ways to use it. Biggest con is that complicated queries can make app logic hairy pretty quickly (but I think proper abstraction layers could probably reduce this friction).
7. **Geo search** - I did this in postgres using cube and earthdistance because it was quick and relatively easy, but I think the _ideal_ solution is more likely _either_ something like OpenSearch, where you can score by geo proximity along side other facets, or PostGIS (for indexing and performance reasons).
8. **Barrelling** - Nx loves barrelling. I get the appeal of it, but _in practice_, I've just seen more negative side effects than positive ones. When you import something with barrelling, you just _can't_ easily know what else you're now bundling with your application. For example, I've got backend and frontend stuff in one monorepo, and if I wasn't careful with barrelling, I could easily end up pulling database stuff into the frontend. It also bloats package sizes and tree shaking is not as straight-forward as people tend to think.
9. **Pagination** - 
